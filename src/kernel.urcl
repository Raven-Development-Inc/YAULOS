// UCOS 0.1.6
//Vibe to this shit thats on fire if ur reading: https://www.youtube.com/watch?v=TeXqIhG0888&list=PL3HjO-9hp7nwftlikzs5dNX58olyahWly&index=5

// Assembly headers
BITS == 16
MINREG 16
MINHEAP 32768
MINSTACK 2048
RUN ROM



//macros
//malloc
@define MALLOC_MAINP M0
//gfx
@define ax r16
@define ay r15
@define bx r14
@define by r13
@define dx r12
@define dy r11
@define sx r10
@define sy r9
@define cx r8
@define cy r7
@define x r6
@define y r5
@define i r4

//Colors
@define BLACK 0
@define DARKBLUE 1
@define DARKPURPLE 2
@define DARKGREEN 3
@define BROWN 4
@define DARKEGREY 5
@define LIGHTGREY 6
@define WHITE 7
@define RED 8
@define ORANGE 9
@define YELLOW 10
@define GREEN 11
@define BLUE 12
@define LAVENDER 13
@define PINK 14
@define LIGHTPEACH 15
//floats
@define F16PI 0x4248
@define F16E  0x4170
@define NAN   0x7fff
//disk
@define diskstart 258

//sounds

@DEFINE d16 100 // 16th note
@DEFINE d8 200 // 8th note
@DEFINE d4 400 // quarter note
@DEFINE d2 800 // half note
@DEFINE df 1600 // full note
@DEFINE d3_8 600 // 3/8th note
@DEFINE d6 267 // triplet
@DEFINE fs 0
@DEFINE g 1
@DEFINE gs 2
@DEFINE a 3
@DEFINE as 4
@DEFINE b 5
@DEFINE c 6
@DEFINE cs 7
@DEFINE d 8
@DEFINE ds 9
@DEFINE e 10
@DEFINE f 11

@DEFINE fs1 12
@DEFINE g1 13
@DEFINE gs1 14
@DEFINE a1 15
@DEFINE as1 16
@DEFINE b1 17
@DEFINE c1 18
@DEFINE d1 19
@DEFINE ds1 20
@DEFINE e1 21
@DEFINE f1 22
@DEFINE a2 23
@DEFINE as2 24
@DEFINE b2 25
@DEFINE c2 26
@DEFINE len r8
.sys_vars
    dw 0
.mouse_x_y
    dw [0 0]
.mouse_button_status
    dw 0

.VirtualRegisters //For processing
    DW [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] // R0 - R15

.Process_Descriptor_table //pointers to the proccess descripters
    DW [ 0 0 0 0 0 0 0 0 0 0 ] //descriptor pointer cannot be a 0, because 0 = free
    
//Process descriptor format:
//PID
//Start of program
//Name of program (string pointer)
//Current read address
//dw value location
//program binary location
//Heap location
//Stack location
//Memory access(protection level 0 = like fuck u, you only can use heap+stack+dw values. 15 = aight use whatever the hell you want)
//Error status
//Registers using (1-15)




//OS Vars
.Bits
	dw @bits
.MinReg
	dw @minreg
.MinStack
	dw @minstack
.MinHeap
	dw @minheap

.currentDirectory
        dw 0 //root dir = 0th dir current DIR is the Index of the directory

//stuff
//damn, tons of RAM used
	.e
		dw ["Setting up SimplexFS please be patient" 0] //tell the user wtf we are doing
	.e1
		dw ["10% done" 0] //telling the user how much of the proccess is done
		//because im nice
	.e2
		dw ["20% done" 0]
	.e3 
		dw ["30% done" 0]
	.e4 
		dw ["40% done" 0]
	.e5 
		dw ["50% done" 0]
	.e6 
		dw ["60% done" 0]
	.e7 
		dw ["70% done" 0]
	.e8 
		dw ["80% done" 0]
	.e9
		dw ["90% done" 0]
	.e10
		dw ["File system installed, creating root directory..." 0]
	.e12
		dw ["Programs installed, loading shell.exe..." 0]
	.e13
		dw ["Shell loaded, starting, enjoy session %d - User: %s" 0]

.Syscalls //13 sys calls so far, expanding the fs right now (2 wrappers, they don't count)
	dw .os_get_api_version //1
	dw .os_get_ucos_version //2
	dw .os_error //3
	dw .os_change_page //4
	dw .os_peek //5
	dw .os_poke //6
	dw .os_create_file //7
	dw .os_delete_file //8
	dw .os_format_disk //9
	dw .os_create_dir //10
	dw .os_delete_dir //11
	dw .os_change_dir //12
	dw .os_print_wd //13
	dw .render_sprite //14
	dw .window_render //15
	
	//Wrappers to interact with stdlib
	dw .Malloc
	dw .Free
	dw .Defrag

//boot
jmp .Init
// Code
.Init
	cal .init_malloc
	cal .os_get_ucos_version
        cal .os_format_disk
	jmp .Init //infinite loop, not done yet
	
// Some syscalls ------------------------------------------------------------
.Scal
	
	brg .Ins_SystemCall_InvalidSyscall r1 15
        .scal_1
	llod r15 .Syscalls r1
	cal r15
        ret

//----------------------------------------------------------------------------------------
//Errors ---------------------------------------------------------------------------------
.Ins_SystemCall_InvalidSyscall
	STR .errorCode 1
	jmp .scal_1

//----------------------------------------------------------------------------------------

//Misc------------------------------------------------------------------------------------
.os_get_ucos_version //Print ucos Version
	imm r1 .version1
	psh .version2
	cal .printf
	ret
.os_get_api_version //Prints API version
	imm r1, .api_version
	cal .printf
	ret
.os_error //Error code goes in .errorCode use llod to change it(is an int bc memory constraints)
	psh r1
	imm r1 .errorCode
	out %uint r1
	pop r1
	ret

//Disk -----------------------------------------------------------------------------------

.os_peek //IN: r1 = address OUT: r2 = data
	out %addr r1
	in r2 %BUS
	ret
.os_poke //IN: r1 = address r2 = data 
	out %addr r1
	out %bus r2
	ret
	
.os_change_page //IN: r1 = page num(65536 byte pages)
	out %page r1
	ret
	
.os_write_block //IN: data array pointer
	

//----------------------------------------------------------------------------------------

// SimplexFS
.os_format_disk //only call this once
	// oh crap, gonna be a lot of imms and incs and cal os_pokes
	
	imm r1 .e
	cal .printf
	imm r1 0
	
	
	// Starting the proccess!
	cal .os_change_page
	imm r1 0 //first 64k page
	
	//load the magic number in simplex
	imm r2 0xfe 
	cal .os_poke 
	inc r1 r1
	imm r2 0xca
	cal .os_poke
	inc r1 r1
	imm r2 0x01
	cal .os_poke
	inc r1 r1
	imm r2 0x32
	cal .os_poke
	inc r1 r1 
	imm r2 0x94
	cal .os_poke
	inc r1 r1
	
	psh r1
	imm r1 .e1
	cal .printf
	pop r1
	
	//ok, now load the number of sectors, remember, 256 byte sectors this header just BARELY fits in 256 bytes(254 bytes)
	//so, 2^24/256 = 65536, great! just one imm, actually 2 bcause length of 2 
	imm r2 0xffff
	cal .os_poke
	inc r1 r1 
	imm r2 0x0000
	cal .os_poke
	inc r1 r1
	
	psh r1
	imm r1 .e2
	cal .printf
	pop r1
	//also, the checksum headers aren't a thing, so the header is actually
	//smaller
	
	//FAT size(as in the size of the table) in 16 bit entries(0x0000 means the sector is
	//unallocated, 0xffff means it is)
	imm r2 0xffff //(65535 bytes or 8 files holy shit thats big, but thats only 8 files
	//in a pool of 2048 files so idgaf)
	cal .os_poke
	inc r1 r1
	imm r2 0x0000 //padding
	cal .os_poke
	inc r1 r1s
	
	psh r1
	imm r1 .e3
	cal .printf
	pop r1
	
	//FAT size in sectors
	//65536/256 = 256
	//so...
	imm r2 0x00ff
	cal .os_poke
	inc r1 r1
	imm r2 0x0000 //more padding(mind you this fs is designed for 8 bit embeded systems
	//so a 16 bit value would be separated into 2 8 bit values)
	cal .os_poke
	inc r1 r1
	
	psh r1
	imm r1 .e4
	cal .printf
	pop r1
	
	//sector indes of root dir(it is 258)
	imm r2 258 //idk the hex for 258 and am too lazy to search it up
	cal .os_poke
	inc r1 r1 
	imm r2 0x0000 //WHY SO MUCH PADDING YOU SU-
	cal .os_poke
	inc r1 r1 
	
	psh r1
	imm r1 .e5
	cal .printf
	pop r1
	
	//version of simplex: 1.0
	imm r2 0x0100
	cal .os_poke
	inc r1 r1 
	imm r2 0x0000
	cal .os_poke
	inc r1 r1 
	
	psh r1
	imm r1 .e6
	cal .printf
	pop r1
	
	//media type: generic or 0x00
	imm r2 0x0000
	cal .os_poke
	inc r1 r1 
	
	psh r1
	imm r1 .e7
	cal .printf
	pop r1
	
	//sxh_id: none, just fill the void
	cal .os_poke //0x0000 already exists in r2 so u dont have to change it
	inc r1 r1 
	cal .os_poke
	inc r1 r1
	
	psh r1
	imm r1 .e8
	cal .printf
	pop r1
	
	//Volume id: Drive A
	imm r2 'D'
	cal .os_poke
	inc r1 r1 
	imm r2 'r'
	cal .os_poke
	inc r1 r1 
	imm r2 'i'
	cal .os_poke
	inc r1 r1 
	imm r2 'v'
	cal .os_poke
	inc r1 r1 
	imm r2 'e'
	cal .os_poke
	inc r1 r1 
	imm r2 ' '
	cal .os_poke
	inc r1 r1
	imm r2 'A'
	cal .os_poke
	inc r1 r1 	
	
	psh r1
	imm r1 .e9
	cal .printf
	pop r1
	
	//root len
	imm r2 0
	cal .os_poke
	
	ret
.os_create_file
	ret
.os_delete_file
	ret
.os_create_dir
	ret
.os_delete_dir
	ret
.os_change_dir
	lstr .currentDirectory r1 0
	ret
.os_print_wd
	lod r1 .currentDirectory
	cal .print_int
	ret
.os_write_file
        ret
	
//Gfx ------------------------------------------------------------------------------------
.render_sprite   
    //@debug
    psh r1 // pointer
    psh r2 // off_x
    psh r3 // off_y
    psh r4 // h
    lod r4 r1 // h = data[0]
    psh r5 // w
    llod r5 r1 1 // w = data[1]
    psh r6 // y
    imm r6 0
    psh r7 // x
    imm r7 0
    psh r8 // additional info
    add r1 r1 2 // ndata = data[2:]
    out %buffer 1
    .render_foryinrangeh
       .render_foryinrangeh_forxinrangew
           psh r7
           add r7 r7 r2
           out %x r7
           pop r7
           psh r6
           add r6 r6 r3
           out %y r6
           pop r6
           mlt r8 r6 r5
           add r8 r8 r7
           llod r8 r8 r1
           out %color r8
           inc r7 r7
           bne .render_foryinrangeh_forxinrangew r7 r5
       imm r7 0
       inc r6 r6
       bne .render_foryinrangeh r6 r4 
    out %buffer 2
    pop r8
    pop r7
    pop r6
    pop r5
    pop r4
    pop r3
    pop r2
    pop r1
    ret
   
// ---------------------------------------------------------------------------------------
//Wrappers -------------------------------------------------------------------------------
.Halt
	hlt
.Malloc
	cal .malloc
.Free
	cal .free
.Defrag
	cal .defragm

//----------------------------------------------------------------------------------------
// Window support(WIP) -------------------------------------------------------------------
.window_render //Render Window
    psh r1 //window
    psh r2
    psh r3
    llod r2 r1 1
    llod r3 r1 2
    lod r1 r1
    cal .render_sprite
    pop r3
    pop r2
    pop r1
    psh r1
    psh r2
    psh r3
    llod r2 r1 3 // buttons *
    
    .window_render_rereimplement__cycle
        lod r3 r2
        bre .window_render_rereimplement__end r3 0
       // hlt
        psh r1
        psh r2
        psh r3
        mov r3 r1
        mov r1 r2
        mov r2 r3
        cal .button_render
        inc r2 r2
        jmp .window_render_rereimplement__cycle
    .window_render_rereimplement__end
    pop r3
    pop r2
    pop r1
    pop r3
    pop r2
    pop r1
    ret
    
.button_render //Render a button
    psh r1 // button*
    psh r2 // window*
    psh r3 // additional
    psh r4
    psh r5 // wx
    psh r6 // wy
    bre .button_render__end r1 0
    llod r5 r2 1
    llod r6 r2 2 // init of offsetted x & y
    lod r1 r1
    
    llod r3 r1 0 // x
    add r2 r3 r5
    llod r4 r1 1 // y
    add r3 r4 r6

    llod r1 r1 4 // graphics*, but we need to get x and y into R2 and R3 first
    cal .render_sprite
    .button_render__end
	pop r6
	pop r5
	pop r4
	pop r3
	pop r2
	pop r1
	ret

.button_fill //Fill a button with color
    psh r1 // button *
    psh r2 // color
    psh r3 // additional info
    psh r4
    psh r5
    lod r1 r1
    llod r1 r1 4 // graphics *
    lod r4 r1
    llod r5 r1 1
    mlt r4 r4 r5
    add r1 r1 2
    .button_fill__loop1
        str r1 r2
        dec r4 r4
        bre .button_fill__end r4 0
        inc r1 r1
        jmp .button_fill__loop1
    .button_fill__end
        pop r5
        pop r4
        pop r3
        pop r2
        pop r1
        ret

.index_of_0 //idk
    psh r1 // ptr
    psh r2 // additional
    psh r3 // additional
    imm r3 0
    .index_of_0__loop1
        llod r2 r1 r3
        brz .index_of_0_found r2
        inc r3 r3
        jmp .index_of_0__loop1
    .index_of_0_found
        mov r1 r3
        pop r3
        pop r2
        pop r9
        ret
	
.button_create //Create a button in window
    psh r1 // window*
    psh r2 // x
    psh r3 // y
    psh r4 // h
    psh r5 // w
    psh r6
    //psh r1
    add r1 r1 3 // button ***
    lod r1 r1
    psh r1
    cal .index_of_0
    pop r6 // r1 - index for button to placed at, r2 - button **
    add r1 r1 r6 // pointer for button to placed at
    mov r6 r1
    imm r1 5
    cal .malloc
    str r1 r2
    lstr r1 1 r3
    lstr r1 2 r4
    lstr r1 3 r5
    mov r2 r1
    mlt r1 r4 r5
    add r1 r1 2
    cal .malloc
    str r1 r4
    lstr r1 1 r5
    lstr r2 4 r1
    str r6 r2
    mov r1 r6
    pop r6
    pop r5
    pop r4
    pop r3
    pop r2
    pop r9
    ret
    
.window_create //Create Window
    psh r1 // h
    psh r2 // w
    psh r3 // additional data
    mlt r3 r2 r1
    psh r1
    mov r1 r3
    add r1 r1 2
    cal .malloc
    mov r3 r1
    pop r1
    lstr r3 0 r1
    lstr r3 1 r2 // r1, r2 - useless, r3 - graphics*
    imm r1 4
    cal .malloc
    str r1 r3
    lstr r1 1 0
    lstr r1 2 0
    mov r2 r1
    imm r1 16 // buttons
    cal .malloc
    lstr r2 3 r1
    pop r3
    mov r1 r2
    pop r2
    pop r9
    ret

.window_fill //Fill a window with color lolol
    psh r1 // window*
    psh r2 // color
    psh r3 // additional reg
    psh r4 // additional reg
    lod r3 r1
    lod r4 r3
    llod r3 r3 1
    mlt r3 r3 r4 // total size
    lod r1 r1
    add r1 r1 2 
    .window_fill_reimplement__loop1
        str r1 r2
        dec r3 r3
        bre .window_create_reimplement__end r3 0
        inc r1 r1
        jmp .window_fill_reimplement__loop1
    .window_create_reimplement__end
        pop r4
        pop r3
        pop r2
        pop r1
        ret



//----------------------------------------------------------------------------------------
//Renders --------------------------------------------------------------------------------
.render_letter
    psh r1 //char
    psh r2 // x
    psh r3 // y
    sub r1 r1 32
    mlt r1 r1 27
    add r1 r1 .space1
    cal .render_sprite
    pop r3
    pop r2
    pop r1
    ret

.render_string
    psh r1 // str*
    psh r2 // x
    imm r2 0
    psh r3 // y
    imm r3 0
    .render_string__loop1
        psh r1
        lod r1 r1
        bre .render_string__end r1 0
        bre .render_string__newline r1 0xa0
        cal .render_letter
        pop r1
        inc r1 r1
        add r2 r2 6
        jmp .render_string__loop1
    .render_string__newline
        pop r1
        add r3 r3 6
        imm r2 0
        inc r1 r1
        jmp .render_string__loop1
    .render_string__end
        pop r1
        pop r3
        pop r2
        pop r1
        ret
// ---------------------------------------------------------------------------------------
//Mouse ----------------------------------------------------------------------------------
.mouse_scan
	psh r1
	in r1 %MOUSE_X
	lstr .mouse_x_y 0 r1
	in r1 %MOUSE_Y
	lstr .mouse_x_y 1 r1
	in r1 %MOUSE_BUTTONS
	str .mouse_button_status r1
	pop r1
	ret
//----------------------------------------------------------------------------------------
// OS variables
.version1 //pls dont change
	dw ["UCOS Version %s" 0xa0 0]
.version2 //pls dont change
	dw ["0.1.6 alpha" 0]
.api_version //pls dont change
	dw ["7" 0]
.errorCode //change with llod
	dw 0
//Errors:
//0: none
//1: syscall doesn't exist
//2: memory address out of bounds
//3: OS ProdActivate Key failed (WIP)
//4: Fatal Error: Kernel Panic call panic(void);
//5: bad command
//6: char doesn't exist
//7: sprite doesn't exist
//8: syscall ident cant be a negative


//Shell Start ----------------------------------------------------------------------------

.Shell
	jmp .ShellEnd
.ShellEnd
	jmp .Halt
	
//Shell End ------------------------------------------------------------------------------
//Font -----------------------------------------------------------------------------------
.space1
    dw [5 5]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
.exclamationMark1
    dw [5 5]
    dw [0 7 0 0 0]
    dw [0 7 0 0 0]
    dw [0 7 0 0 0]
    dw [0 0 0 0 0]
    dw [0 7 0 0 0]
.quote1
    dw [5 5]
    dw [0 7 0 7 0]
    dw [0 7 0 7 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]

.hashtag
    dw [5 5]
    dw [0 7 0 7 0]
    dw [7 7 7 7 7]
    dw [0 7 0 7 0]
    dw [7 7 7 7 7]
    dw [0 7 0 7 0]
.dollarSign
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 7 0 0]
    dw [0 7 7 7 0]
    dw [0 0 7 0 7]
    dw [0 7 7 7 0]
.percentSign    
    dw [5 5]
    dw [0 7 0 7 0]
    dw [0 0 0 7 0]
    dw [0 0 7 0 0]
    dw [0 7 0 0 0]
    dw [0 7 0 7 0]
.andSign
    dw [5 5]
    dw [0 0 7 0 0]
    dw [0 7 0 7 0]
    dw [0 0 7 0 0]
    dw [0 7 0 7 0]
    dw [0 7 7 7 0]
.singlequotesign
    dw [5 5]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
.leftParenthesis
    dw [5 5]
    dw [0 0 7 0 0]
    dw [0 7 0 0 0]
    dw [0 7 0 0 0]
    dw [0 7 0 0 0]
    dw [0 0 7 0 0]
.rightParenthesis
    dw [5 5]
    dw [0 0 7 0 0]
    dw [0 0 0 7 0]
    dw [0 0 0 7 0]
    dw [0 0 0 7 0]
    dw [0 0 7 0 0]
.starSign
    dw [5 5]
    dw [0 0 0 0 0]
    dw [0 7 0 7 0]
    dw [0 0 7 0 0]
    dw [0 7 0 7 0]
    dw [0 0 0 0 0]
.plusSign
    dw [5 5]
    dw [0 0 0 0 0]
    dw [0 0 7 0 0]
    dw [0 7 7 7 0]
    dw [0 0 7 0 0]
    dw [0 0 0 0 0]
.commaSign
    dw [5 5]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 7 0 0]
    dw [0 7 0 0 0]
.dashSign
    dw [5 5]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [7 7 7 7 7]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
.dotSign
    dw [5 5]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 7 0 0 0]
.slashSign
    dw [5 5]
    dw [0 0 0 7 0]
    dw [0 0 0 7 0]
    dw [0 0 7 0 0]
    dw [0 7 0 0 0]
    dw [0 7 0 0 0]
.zeroNumb
    dw [5 5]
    dw [0 7 7 0 0]
    dw [7 0 0 7 0]
    dw [7 0 0 7 0]
    dw [7 0 0 7 0]
    dw [0 7 7 0 0]
.oneNumb
    dw [5 5]
    dw [0 0 7 0 0]
    dw [0 7 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 7 7 7 0]
.twoNumb
    dw [5 5]
    dw [0 7 7 7 0]
    dw [0 0 0 0 7]
    dw [0 0 7 7 0]
    dw [0 7 0 0 0]
    dw [0 7 7 7 7]
.threeNumb
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 7]
    dw [0 0 7 7 0]
    dw [7 0 0 0 7]
    dw [0 7 7 7 0]
.fourNumb
    dw [5 5]
    dw [0 7 0 7 0]
    dw [0 7 0 7 0]
    dw [0 7 7 7 0]
    dw [0 0 0 7 0]
    dw [0 0 0 7 0]
.fiveNumb
    dw [5 5]
    dw [0 7 7 7 0]
    dw [0 7 0 0 0]
    dw [0 7 7 7 0]
    dw [0 0 0 7 0]
    dw [0 7 7 0 0]
.sixNumb
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 0]
    dw [7 7 7 7 0]
    dw [7 0 0 0 7]
    dw [0 7 7 7 0]
.sevenNumb
    dw [5 5]
    dw [0 7 7 7 0]
    dw [0 0 0 7 0]
    dw [0 0 0 7 0]
    dw [0 0 0 7 0]
    dw [0 0 0 7 0]
.eightNumb
    dw [5 5]
    dw [0 7 7 0 0]
    dw [7 0 0 7 0]
    dw [0 7 7 0 0]
    dw [7 0 0 7 0]
    dw [0 7 7 7 0]
.nineNumb
    dw [5 5]
    dw [0 7 7 0 0]
    dw [7 0 0 7 0]
    dw [0 7 7 7 0]
    dw [0 0 0 7 0]
    dw [0 7 7 0 0]
.doubledotsign
    dw [5 5]
    dw [0 0 0 0 0]
    dw [0 7 0 0 0]
    dw [0 0 0 0 0]
    dw [0 7 0 0 0]
    dw [0 0 0 0 0]
.semicolonsign
    dw [5 5]
    dw [0 7 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 7 0 0 0]
    dw [7 0 0 0 0]
.lesssign
    dw [5 5]
    dw [0 0 0 7 7]
    dw [0 7 7 0 0]
    dw [7 0 0 0 0]
    dw [0 7 7 0 0]
    dw [0 0 0 7 7]
.equalsing
    dw [5 5]
    dw [0 0 0 0 0]
    dw [7 7 7 7 7]
    dw [0 0 0 0 0]
    dw [7 7 7 7 7]
    dw [0 0 0 0 0]
.greatersign
    dw [5 5]
    dw [7 7 0 0 0]
    dw [0 0 7 7 0]
    dw [0 0 0 0 7]
    dw [0 0 7 7 0]
    dw [7 7 0 0 0]
.questionmark
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 7]
    dw [0 0 7 7 0]
    dw [0 0 0 0 0]
    dw [0 0 7 0 0]
.dogsign
    dw [5 5]
    dw [0 0 7 7 0]
    dw [7 7 0 0 7]
    dw [7 7 7 0 7]
    dw [7 0 0 0 7]
    dw [0 7 7 7 0]
.letterA_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 7 7 7 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]

.letterB_rend
    dw [5 5]
    dw [7 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 7 7 7 7]

.letterC_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 0 0 0 0]
    dw [7 0 0 0 7]
    dw [0 7 7 7 0]

.letterD_rend
    dw [5 5]
    dw [7 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 7 7 7 0]

.letterE_rend
    dw [5 5]
    dw [7 7 7 7 7]
    dw [7 0 0 0 0]
    dw [7 7 7 7 0]
    dw [7 0 0 0 0]
    dw [7 7 7 7 7]

.letterF_rend
    dw [5 5]
    dw [7 7 7 7 7]
    dw [7 0 0 0 0]
    dw [7 7 7 7 0]
    dw [7 0 0 0 0]
    dw [7 0 0 0 0]

.letterG_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 0]
    dw [7 0 0 7 7]
    dw [7 0 0 0 7]
    dw [0 7 7 7 0]

.letterH_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 7 7 7 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]

.letterI_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 7 7 7 0]
.letterJ_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [7 0 7 0 0]
    dw [0 7 7 0 0]

.letterK_rend
    dw [5 5]
    dw [7 0 0 7 0]
    dw [7 0 7 0 0]
    dw [7 7 0 0 0]
    dw [7 0 7 0 0]
    dw [7 0 0 7 0]

.letterL_rend
    dw [5 5]
    dw [7 0 0 0 0]
    dw [7 0 0 0 0]
    dw [7 0 0 0 0]
    dw [7 0 0 0 0]
    dw [7 7 7 0 0]
.letterM_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 7 0 7 7]
    dw [7 0 7 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
.letterN_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 7 0 0 7]
    dw [7 0 7 0 7]
    dw [7 0 0 7 7]
    dw [7 0 0 0 7]
.letterO_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [0 7 7 7 0]
.letterP_rend
    dw [5 5]
    dw [7 7 7 0 0]
    dw [7 0 0 7 0]
    dw [7 7 7 0 0]
    dw [7 0 0 0 0]
    dw [7 0 0 0 0]
.letterQ_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 0 7 0 7]
    dw [7 0 0 7 0]
    dw [0 7 7 0 7]
.letterR_rend
    dw [5 5]
    dw [7 7 7 0 0]
    dw [7 0 0 7 0]
    dw [7 7 7 0 0]
    dw [7 0 0 7 0]
    dw [7 0 0 7 0]
.letterS_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 0]
    dw [0 7 7 7 0]
    dw [0 0 0 0 7]
    dw [0 7 7 7 0]
.letterT_rend
    dw [5 5]
    dw [7 7 7 7 7]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
.letterU_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [0 7 7 7 7]
.letterV_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [0 7 0 7 0]
    dw [0 7 0 7 0]
    dw [0 0 7 0 0]
.letterW_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 7 0 7]
    dw [7 7 0 7 7]

.letterX_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [0 7 0 7 0]
    dw [0 0 7 0 0]
    dw [0 7 0 7 0]
    dw [7 0 0 0 7]
.letterY_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [0 7 0 7 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
.letterZ_rend
    dw [5 5]
    dw [7 7 7 7 7]
    dw [0 0 0 7 0]
    dw [0 0 7 0 0]
    dw [0 7 0 0 0]
    dw [7 7 7 7 7]
.leftsquareParethesisSign
    dw [5 5]
    dw [0 7 7 0 0]
    dw [0 7 0 0 0]
    dw [0 7 0 0 0]
    dw [0 7 0 0 0]
    dw [0 7 7 0 0]
.backSlashSign
    dw [5 5]
    dw [0 7 0 0 0]
    dw [0 7 0 0 0]
    dw [0 0 7 0 0]
    dw [0 0 0 7 0]
    dw [0 0 0 7 0]
.rightsquareParethesisSign
    dw [5 5]
    dw [0 0 7 7 0]
    dw [0 0 0 7 0]
    dw [0 0 0 7 0]
    dw [0 0 0 7 0]
    dw [0 0 7 7 0]
.upSign
    dw [5 5]
    dw [0 0 7 0 0]
    dw [0 7 0 7 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
.downDashSign
    dw [5 5]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [7 7 7 7 7]
.sidequotesign
    dw [5 5]
    dw [0 7 0 0 0]
    dw [0 0 7 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
.lletterA_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 7 7 7 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]

.lletterB_rend
    dw [5 5]
    dw [7 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 7 7 7 7]

.lletterC_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 0 0 0 0]
    dw [7 0 0 0 7]
    dw [0 7 7 7 0]

.lletterD_rend
    dw [5 5]
    dw [7 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 7 7 7 0]

.lletterE_rend
    dw [5 5]
    dw [7 7 7 7 7]
    dw [7 0 0 0 0]
    dw [7 7 7 7 0]
    dw [7 0 0 0 0]
    dw [7 7 7 7 7]

.lletterF_rend
    dw [5 5]
    dw [7 7 7 7 7]
    dw [7 0 0 0 0]
    dw [7 7 7 7 0]
    dw [7 0 0 0 0]
    dw [7 0 0 0 0]

.lletterG_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 0]
    dw [7 0 0 7 7]
    dw [7 0 0 0 7]
    dw [0 7 7 7 0]

.lletterH_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 7 7 7 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]

.lletterI_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 7 7 7 0]
.lletterJ_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [7 0 7 0 0]
    dw [0 7 7 0 0]

.lletterK_rend
    dw [5 5]
    dw [7 0 0 7 0]
    dw [7 0 7 0 0]
    dw [7 7 0 0 0]
    dw [7 0 7 0 0]
    dw [7 0 0 7 0]

.lletterL_rend
    dw [5 5]
    dw [7 0 0 0 0]
    dw [7 0 0 0 0]
    dw [7 0 0 0 0]
    dw [7 0 0 0 0]
    dw [7 7 7 0 0]
.lletterM_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 7 0 7 7]
    dw [7 0 7 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
.lletterN_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 7 0 0 7]
    dw [7 0 7 0 7]
    dw [7 0 0 7 7]
    dw [7 0 0 0 7]
.lletterO_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [0 7 7 7 0]
.lletterP_rend
    dw [5 5]
    dw [7 7 7 0 0]
    dw [7 0 0 7 0]
    dw [7 7 7 0 0]
    dw [7 0 0 0 0]
    dw [7 0 0 0 0]
.lletterQ_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 7]
    dw [7 0 7 0 7]
    dw [7 0 0 7 0]
    dw [0 7 7 0 7]
.lletterR_rend
    dw [5 5]
    dw [7 7 7 0 0]
    dw [7 0 0 7 0]
    dw [7 7 7 0 0]
    dw [7 0 0 7 0]
    dw [7 0 0 7 0]
.lletterS_rend
    dw [5 5]
    dw [0 7 7 7 0]
    dw [7 0 0 0 0]
    dw [0 7 7 7 0]
    dw [0 0 0 0 7]
    dw [0 7 7 7 0]
.lletterT_rend
    dw [5 5]
    dw [7 7 7 7 7]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
.lletterU_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [0 7 7 7 7]
.lletterV_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [0 7 0 7 0]
    dw [0 7 0 7 0]
    dw [0 0 7 0 0]
.lletterW_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 0 0 7]
    dw [7 0 7 0 7]
    dw [7 7 0 7 7]

.lletterX_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [0 7 0 7 0]
    dw [0 0 7 0 0]
    dw [0 7 0 7 0]
    dw [7 0 0 0 7]
.lletterY_rend
    dw [5 5]
    dw [7 0 0 0 7]
    dw [0 7 0 7 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
.lletterZ_rend
    dw [5 5]
    dw [7 7 7 7 7]
    dw [0 0 0 7 0]
    dw [0 0 7 0 0]
    dw [0 7 0 0 0]
    dw [7 7 7 7 7]
.figurerightParenthesisSign
    dw [5 5]
    dw [0 0 7 7 0]
    dw [0 0 7 0 0]
    dw [0 7 0 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 7 0]
.straightLineSign
    dw [5 5]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 7 0 0]
.figureleftParenthesisSign
    dw [5 5]
    dw [0 7 7 0 0]
    dw [0 0 7 0 0]
    dw [0 0 0 7 0]
    dw [0 0 7 0 0]
    dw [0 7 7 0 0]
.tildaSign
    dw [5 5]
    dw [0 7 0 0 0]
    dw [7 0 7 0 7]
    dw [0 0 0 7 0]
    dw [0 0 0 0 0]
    dw [0 0 0 0 0]
.deleteSign
    dw [5 5]
    dw [7 7 0 7 0]
    dw [7 0 7 7 0]
    dw [7 7 0 7 0]
    dw [0 0 0 7 0]
    dw [0 0 0 7 7]
//Font End ------------------------------------------------------------------------------

//STDLIB-URCL v2 -------------------------------------------------------------------------


//Memory.urcl ----------------------------------------------------------------------------
.init_malloc //init_malloc();
str MALLOC_MAINP 0xffff
ret

//malloc();
.malloc
    psh r1 // size
    psh r2 // dynamic malloc_start*
    imm r2 MALLOC_MAINP
    psh r3 // additional reg
    psh r4
    .malloc__loop1
        lod r3 r2
        brg .malloc__found__free r3 0x8000
        and r3 r3 0x7fff
        mov r2 r3
        jmp .malloc__loop1
    
    .malloc__found__free
        and r3 r3 0x7fff // getting address of next chunk (can work as size indicator)
        sub r4 r3 r2 // size of chunk available
        brl .malloc__found r1 r4
        // bre .malloc__found__partition__needed r1 r4
        bre .malloc__fail r3 0x7fff // check for failure
        bre .malloc__fail r3 0x0000
        mov r2 r3
        jmp .malloc__loop1
    .malloc__fail
        pop r4
        pop r3
        pop r2
        pop r1
        imm r1 0xffff // -1
        ret
    .malloc__found
        bne .malloc__found__skip r3 0x7fff // if ( address_of_the_next_chunk == 0x7fff) {
        // r1 - size, r2 - pointer to curr chunk, r3 - addr to next chunk, r4 - size of chunk
        psh r4
        mov r4 r1
        add r4 r4 r2
        and r4 r4 0x7fff
        add r4 r4 1
        str r2 r4
        str r4 0xffff
        pop r4
        jmp .malloc__end
        // }
        .malloc__found__skip 
        bre .malloc__found__skip2 r1 r4 // if ( chunk_size != req_size ) { -> fragmentation
        psh r4
        psh r3
        or r3 r3 0x8000 // making header from address
        mov r4 r1 // 
        add r4 r4 r2 // pointer to next header
        and r4 r4 0x7fff 
        add r4 r4 1 // making offset
        str r2 r4
        lod r5 r4
        bne .malloc__found__endstack r5 0xffff // if ( r4* == END_OF_MALLOC_STACK ) {
        str r4 0xffff
        jmp .malloc__found__endstack_2
        .malloc__found__endstack // } else {
        str r4 r3
        .malloc__found__endstack_2 // }
        pop r3
        pop r4
        jmp .malloc__end
        .malloc__found__skip2 // } else { -> simple address storing
        and r3 r3 0x8000
        str r2 r3
        .malloc__end
        pop r4
        pop r3
        mov r1 r2
        inc r1 r1
        pop r2
        pop r0
        ret

//fastFree();
.fast_free 
    psh r1 // pointer
    psh r2 // additional data
    psh r3
    psh r4
    and r1 r1 0x7fff
    dec r1 r1
    lod r2 r1
    brg .fast_free__alreadyfree r2 0x7fff
    bre .fast_free__alreadyfree r2 0
    sub r3 r2 r1 // size
    dec r3 r3
    inc r1 r1
    mov r4 r1
    dec r1 r1
    .fast_free__loop1
        str r4 0
        inc r4 r4
        dec r3 r3
        bre .fast_free__freed r3 0
        jmp .fast_free__loop1
.fast_free__freed
    or r2 r2 0x8000
    str r1 r2
.fast_free__alreadyfree
    cal .defragm
    pop r4
    pop r3
    pop r2
    pop r1
    ret
.defragm
    psh r1 // pointer
    psh r2 // additional data
    psh r3
    lod r2 r1
    brl .defragm_end r2 0x8000 // not free
    and r2 r2 0x7fff
    lod r3 r2
    brl .defragm_end r3 0x8000
    and r3 r3 0x7fff
    str r1 r3
    str r2 0
    .defragm_end
    pop r3
    pop r2
    pop r1
    ret

.free   //free();
    psh r1 // pointer
    psh r2 // additional data
    psh r3
    psh r4
    and r1 r1 0x7fff
    dec r1 r1
    lod r2 r1
    brg .free__alreadyfree r2 0x7fff
    bre .free__alreadyfree r2 0
    sub r3 r2 r1 // size
    dec r3 r3
    inc r1 r1
    mov r4 r1
    dec r1 r1
    .free__loop1
        str r4 0
        inc r4 r4
        dec r3 r3
        bre .free__freed r3 0
        jmp .free__loop1
.free__freed
    or r2 r2 0x8000
    str r1 r2
.free__alreadyfree
    cal .defragm_global
    pop r4
    pop r3
    pop r2
    pop r1
    ret
        

.defragm_global //defragmentation
    psh r1 // dynamic malloc heap pointer
    imm r1 MALLOC_MAINP
    psh r2 // additional stuff
    psh r3
    .defragm_global__loop1
        lod r2 r1
        bre .defragm_global__end r2 0xffff
        brg .defragm_global__found r2 0x7fff
        mov r1 r2
        jmp .defragm_global__loop1
    .defragm_global__found
        and r2 r2 0x7fff
        lod r3 r2
        brg .defragm_global__found2 r3 0x7fff
        mov r1 r2
        jmp .defragm_global__loop1
    .defragm_global__found2
        str r1 r3
        str r2 0
        jmp .defragm_global__loop1
    .defragm_global__end
        pop r3
        pop r2
        pop r1
        ret
//EOF ------------------------------------------------------------------------------------
//Gfx.urcl -------------------------------------------------------------------------------
.draw_line // in ax, ay, bx, by; var dx, dy, sx, sy, cx, cy, x, y, i 
    MOV x ax
    MOV y ay

    OUT %X x
    OUT %Y y
    OUT %COLOR 255

    SUB dx bx ax
    IMM sx 1
    BGE .bx_ge_ax bx ax
        IMM sx -1
        SUB dx ax bx
    .bx_ge_ax

    BRE .draw_line_eq_y ay by

    SUB dy by ay
    IMM sy 1
    BGE .by_ge_ay by ay
        IMM sy -1
        SUB dy ay by
    .by_ge_ay

    BRE .draw_line_eq_x ax bx

    RSH cx dx // cx = dx >>> 2
    RSH cy dy // cy = dy >>> 2

    BRG .else dx dy //  if dx < dy
        BGE .end dx dy 
        INC cx cx   //      cx++
    JMP .end        //  else if dx > dy
    .else           //  
        INC cy cy   //      cy++
    .end

    ADD i dx dy
    .loop   // for (i = dx+dy; i != 0; i--)
        BGE .cxg cy cx  //  if cy < cx
            SUB cx cx cy//      cx -= cy
            IMM cy dy   //      cy = dy
            ADD x x sx  //      x += sx
        JMP .cxg_end
        .cxg            // else
            SUB cy cy cx//      cy -= cx
            IMM cx dx   //      cx = dx
            ADD y y sy  //      y += sy
        .cxg_end
        OUT %X x
        OUT %Y y
        OUT %COLOR 255
        DEC i i
        BNZ .loop i
    RET

    .draw_line_eq_y
        BRE .eq_y_ret ax bx
        .eq_y_loop
            ADD x x sx
            OUT %X x
            OUT %COLOR 255
            BNE .eq_y_loop x bx
        .eq_y_ret
        RET

    .draw_line_eq_x
        BRE .eq_x_ret ay by
        .eq_x_loop
            ADD y y sy
            OUT %Y y
            OUT %COLOR 255
            BNE .eq_x_loop y by
        .eq_x_ret
        RET

// image: R1 const Bin[ 64 ]*, x: R2 const int, y: R3 const int,
// src_x: var R4, src_y: var R5, src_i/color: var R6
// screen_width: const R8
.draw_sprite8x8
    IMM R5 0
    .loop_y
        ADD R5 R5 R3
        OUT %Y R5
        SUB R5 R5 R3
        IMM R4 0
        .loop_x
            ADD R4 R4 R2
            OUT %X R4
            SUB R4 R4 R2
            MLT R6 R5 8
            ADD R6 R6 R4
            ADD R6 R6 R1
            LOD R6 R6
            // OUT %NUMB R6
            OUT %COLOR R6
            INC R4 R4
            BLE .loop_x R4 7
        INC R5 R5
        BLE .loop_y R5 7
    RET
//EOF ------------------------------------------------------------------------------------
//float.urcl ----------------------------------------------------------------------------
// FLOAT IMPLEMENTATION: 

//create a float
.float_construct
    psh r1 // main int
    psh r2 // v
    psh r3 // sig 
    psh r4 // e
    brl .float_construct__else1 r1 0x8000
    and r2 r1 0x7fff
    imm r3 1
    jmp .float_construct__else1_conti
    .float_construct__else1
        mov r2 r1
    .float_construct__else1_conti
    bre .float_construct_end_0 r2 0
    imm r4 25
    bge .while_v_over2048 r2 2048
    jmp .while_v_less1024
    .while_v_over2048
        rsh r2 r2
        inc r4 r4
        bge .while_v_over2048 r2 2048
    .while_v_less1024pre
    brl .while_v_less1024 r2 1024
    jmp .while_end
    .while_v_less1024
    lsh r2 r2
    dec r4 r4
    brl .while_v_less1024 r2 1024
    .while_end
    bge .e_over_31 r4 31
    bsl r3 r3 15
    bsl r4 r4 10
    and r2 r2 1023
    or r2 r2 r3
    or r2 r2 r4
    mov r1 r2
    pop r4
    pop r3
    pop r2
    pop r9
    ret
    .e_over_31
    bsl r3 r3 15
    and r3 r3 0x8000
    or r3 r3 0x7c00
    mov r1 r3
    pop r4
    pop r3
    pop r2
    pop r9
    ret
    .float_construct_end_0
        pop r4
        pop r3
        pop r2
        pop r1
        imm r1 0
        ret
//create f16 from short
.f16_from_short
		psh r1
		psh r2
		psh r3
		psh r4
		brg .f16_from_int__if1_else r3 0 
		sub r2 0 r1
		imm r3 1
		jmp .f16_from_int__if1_end
	.f16_from_int__if1_else
		mov r2 r1
	.f16_from_int__if1_end
		bre .f16_from_int__end0 r2 0
		imm r4 25
		brl .f16_from_int__while1_end r2 2048
	.f16_from_int__while1_start
		rsh r2 r2
		inc r4 r4
		bge .f16_from_int__while1_start r2 2048
	.f16_from_int__while1_end
		bge .f16_from_int__while2_end r2 1024
	.f16_from_int__while2_start
		lsh r2 r2
		dec r4 r4
		brl .f16_from_int__while2_start r2 1024
	.f16_from_int__while2_end
		bge .f16_from_int__if2 r4 31
		bsl r3 r3 15
		bsl r4 r4 10
		and r2 r2 1023
		or r2 r2 r3
		or r2 r2 r4
		mov r1 r2
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_from_int__if2
		bsl r3 r3 15
		and r3 r3 0x8000
		or r3 r3 0x7c00
		mov r1 r3
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_from_int__end0
		pop r4
		pop r3
		pop r2
		pop r1
		imm r1 0
		ret

// convert float 16 to int
.f16_to_int
	psh r1 
	psh r2 
	psh r3
	psh r4 
	and r2 r1 1023 
	and r4 r1 0x7c00 
	setne r4 r4 0 
	and r4 r4 1 
	mlt r4 r4 1024 
	or r4 r4 r2
	and r2 r1 0x7c00
	bsr r2 r2 10
	sub r2 r2 25
	sbrl .f16_to_int__if1_else r2 0
	bre .f16_to_int__if1_end r2 0
	bsl r4 r4 r2
	jmp .f16_to_int__if1_end
	.f16_to_int__if1_else
	sub r2 0 r2
	bsr r4 r4 r2
	.f16_to_int__if1_end
	and r1 r1 0x8000
	brz .f16_to_int__end r1
	sub r4 0 r4
	.f16_to_int__end
	mov r1 r4
	pop r4
	pop r3
	pop r2
	pop r9
	ret

.f16_add 
	psh r1 // a
	psh r2 // b 
	psh r3 // sign 
	psh r4 
	psh r5 
	psh r6 
	psh r7 
	psh r8
	xor r3 r2 r1 
	and r3 r3 0x8000
	bre .f16_add__if1_end r3 0
	cal .f16_sub
	pop r8
	pop r7
	pop r6
	pop r5
	pop r4
	pop r3
	pop r2
	pop r9
	ret
	.f16_add__if1_end
		and r3 r1 0x8000
		and r1 r1 0x7fff
		and r2 r2 0x7fff
		bge .f16_add__if2_end r1 r2
		mov r4 r1
		mov r1 r2
		mov r2 r4
	.f16_add__if2_end
		setl r4 r1 0x7c00 
		setl r5 r2 0x7c00 
		and r4 r4 1 
		and r5 r5 1 
		or r4 r4 r5  
		bnz .f16_add__if3_end r4
		setg r4 r1 0x7c00 
		setg r5 r2 0x7c00 
		and r4 r4 1 
		and r5 r5 1 
		or r4 r4 r5 
		bnz .f16_add__if4_end r4
		imm r1 0x7fff
	.f16_add__if4_end 
		or r1 0x7c00 r3
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_add__if3_end
		and r4 r1 0x7c00 
		and r5 r2 0x7c00
		sub r6 r4 r5
		mov r7 r4
		brz .f16_add__if5_else r6
		bsr r8 r6 10
		brz .f16_add__if6_else r5
		and r2 r2 1023 
		or r2 r2 1024 
		bsr r2 r2 r8 
		jmp .f16_add__if6_end
	.f16_add__if6_else
		dec r8 r8 
		bsr r2 r2 r8 
	.f16_add__if6_end
		jmp .f16_add__if5_end
	.f16_add__if5_else
		bnz .f16_add__if7_else r5
		add r1 r1 r2 
		or r1 r1 r3
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret
		jmp .f16_add__if7_end
	.f16_add__if7_else
		and r2 r2 1023 
		or r2 r2 1024
	.f16_add__if7_end
		.f16_add__if5_end
			add r4 r1 r2
			and r5 r4 0x7c00 
			bre .f16_add__if8_end r7 r5
			and r6 r1 1023 
			or r6 r6 1024
			add r8 r6 r2 
			rsh r8 r8
			add r7 r7 0x400 
			and r8 r8 1023 
			or r4 r7 r8
			.f16_add__if8_end
				brl .f16_add__if9_end r4 0x7c00 
				or r1 r3 0x7c00 
				pop r8
				pop r7
				pop r6
				pop r5
				pop r4
				pop r3
				pop r2
				pop r9
				ret
	.f16_add__if9_end
		or r1 r4 r3
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret

.f16_sub
	psh r1 // a
	psh r2 // b 
	psh r3 // sign 
	psh r4 
	psh r5 
	psh r6 
	psh r7 
	psh r8
	psh r9
	xor r3 r1 r2 // a ^ b
	and r3 r3 0x8000  // (a^b) & 0x8000
	brz .f16_sub__if1_end r3 // if((a^b)&0x8000 != 0) {
	xor r2 r2 0x8000
	cal .f16_add // return f16_add(a, b ^ 0x8000);
	pop r9
	pop r8
	pop r7
	pop r6
	pop r5
	pop r4
	pop r3
	pop r2
	pop r9
	ret
	.f16_sub__if1_end // } 
		and r3 r1 0x8000 // sign = a & 0x8000
		lsh r1 r1 // a = a << 1 
		lsh r2 r2 // b = b << 1
		bge .f16_sub__if2_end r1 r2 // if(a < b) {
		mov r4 r1 // swap values and sign
		mov r1 r2
		mov r2 r4
		xor r3 r3 0x8000
	.f16_sub__if2_end // }
		and r5 r1 0xf800 // ax = a & 0xf800
		and r6 r2 0xf800 // bx = b & 0xf800
		setge r7 r1 0xf800 // is a >= 0xf800 ?
		setge r8 r2 0xf800 // is b >= 0xf800 ?
		or r7 r7 r8 // (a >= 0xf800 || b >= 0xf800) ?
		and r7 r7 1 // bool(a >= 0xf800 || b >= 0xf800)
		brz .f16_sub__if3_end r7 // if(a >= 0xf800 || b >= 0xf800) {
		setg r7 r1 0xf800 // is a > 0xf800 ?
		setg r8 r2 0xf800 // is b > 0xf800 ?
		sete r9 r1 r2     // is a == b?
		or r7 r8 r7       // (a > 0xf800 || b > 0xf800) ?
		or r7 r7 r9       // (a > 0xf800 || b > 0xf800 || a == b) ?
		and r7 r7 1       // bool(a > 0xf800 || b > 0xf800 || a == b)
		brz .f16_sub__if4_end r7 // if(a > 0xf800 || b > 0xf800 || a == b) {
		imm r1 0x7fff // return 0x7fff;
		pop r9
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_sub__if4_end // }
		or r7 r3 0x7c00   //res = sign | 0x7c00
		bne .f16_sub__if5_else r1 0xf800 // if(a == 0xf800) {
		mov r1 r7 // return res
		pop r9
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_sub__if5_else // } else {
		xor r1 r7 0x8000 // return res ^ 0x8000;
		pop r9
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_sub__if3_end // } 
		sub r7 r5 r6 // exp_diff = ax - bx;
		mov r8 r5 // exp_part = ax;
		bre .f16_sub__if6_else r7 0 // if(exp_diff != 0) {
		bsr r9 r7 11                // shift = exp_diff >> 11;
		bre .f16_sub__if7_else r6 0 // if (bx != 0) {   
		and r2 r2 2047              // b &= 2047
		or r2 r2 2048               // b |= 2048
		bsr r2 r2 r9                // b >>= shift
		jmp .f16_sub__if7_end       // }
	.f16_sub__if7_else          // else {
		dec r9 r9                   // shift -=1 
		bsr r2 r2 r9                // b >>= shift-1
	.f16_sub__if7_end           // }
		jmp .f16_sub__if6_end       // }
	.f16_sub__if6_else          // else {
		bne .f16_sub__if8_else r6 0 // if(bx == 0) {
		sub r9 r1 r2                // res = a - b
		rsh r9 r9                   // res >>= 1 ; res = (a-b)>>1;
		bne .f16_sub__if9_end r9 0 // if(res == 0) {
		mov r1 r9                   // return res;
		pop r9
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_sub__if9_end // }
		or r1 r9 r3     // return res | sign;
		pop r9
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_sub__if8_else // } else {
		and r2 r2 2047 // b &= 2047
		or r2 r2 2048  // b |= 2048
	.f16_sub__if8_end // }
		.f16_sub__if6_end // }
			sub r9 r1 r2    // 
			and r7 r9 0xf800 
			bne .f16_sub__if11_end r7 r8
			rsh r9 r9 
			or r1 r9 r3
			pop r9
			pop r8
			pop r7
			pop r6
			pop r5
			pop r4
			pop r3
			pop r2
			pop r9
			ret
	.f16_sub__if11_end
		and r5 r1 2047 
		or r5 r5 2048
		sub r6 r5 r2
		bne .f16_sub__if10_end r6 0
		imm r1 0
		pop r9
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_sub__if10_end
		.f16_sub__while1 
		setne r5 r8 0 
		and r7 r6 2048 
		sete r7 r7 0
		and r5 r5 r7
		and r5 r5 1
		brz .f16_sub__while1_end r5
		sub r8 r8 0x800
		bre .f16_sub__while1 r8 0
		lsh r6 r6 
		jmp .f16_sub__while1
	.f16_sub__while1_end
		and r1 r6 2047 
		or r1 r1 r8 
		rsh r1 r1 
		or r1 r1 r3
		pop r9
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret

.f16_mul 
	psh r1 
	psh r2 
	psh r3 
	psh r4 
	psh r5 
	psh r6 
	psh r7 
	psh r8
	xor r3 r2 r1 
	and r3 r3 0x8000 
	and r4 r1 0x8000 
	sete r4 r4 0x8000 
	and r4 r4 1 
	and r5 r2 0x8000 
	sete r5 r5 0x8000 
	and r5 r5 1 
	or r4 r4 r5 
	brz .f16_mul__if1_end r4
	and r4 r1 0x7fff 
	setg r4 r4 0x7c00 
	and r4 r4 1 
	and r5 r2 0x7fff 
	setg r5 r5 0x7c00 
	and r5 r5 1 
	or r4 r4 r5 
	brz .f16_mul__if2_end r4
	imm r1 0x7fff
	pop r8
	pop r7
	pop r6
	pop r5
	pop r4
	pop r3
	pop r2
	pop r9
	ret
	.f16_mul__if2_end
		or r1 r3 0x7c00
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_mul__if1_end
		and r4 r1 0x7fff 
		sete r4 r4 0 
		and r4 r4 1 
		and r5 r2 0x7fff 
		sete r5 r5 0 
		and r5 r5 1 
		or r4 r4 r5
		brz .f16_mul__if3_end r4
		imm r1 0
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_mul__if3_end
		and r4 r1 0x7c00 
		setne r4 r4 0 
		and r4 r4 1 
		mlt r4 r4 1024 
		and r5 r1 1023 
		or r4 r4 r5
		and r5 r2 0x7c00 
		setne r5 r5 0 
		and r5 r5 1 
		mlt r5 r5 1024 
		and r6 r2 1023 
		or r5 r5 r6
		mlt r8 r4 r5 
		umlt r7 r4 r5
		mov r4 r8
		and r5 r1 0x7c00 
		bsr r5 r5 10 
		sete r6 r5 0 
		and r6 r6 1 
		add r5 r5 r6
		and r6 r2 0x7c00 
		bsr r6 r6 10 
		sete r8 r6 0 
		and r8 r8 1 
		add r6 r6 r8
		add r5 r5 r6 
		sub r5 r5 15
		and r8 r8 0b10000 
		bre .f16_mul__if4_elseif r8 0 
		psh r7 
		bsr r7 r7 11 
		bsr r4 r4 11 
		pop r8 
		bsl r8 r8 5 
		or r4 r4 r8
		inc r5 r5
		jmp .f16_mul__if4_end
	.f16_mul__if4_elseif
		and r8 r7 0b1000 
		bre .f16_mul__if4_else r8 0
		psh r7
		psh r7 
		bsr r7 r7 10 
		bsr r4 r4 10 
		pop r8
		pop r7  
		bsl r8 r8 6 
		or r4 r4 r8
		jmp .f16_mul__if4_end
	.f16_mul__if4_else
		sub r5 r5 10
	.f16_mul__while1 
		setge r1 r4 2048 
		and r1 r1 1 
		setne r2 r7 0
		and r2 r2 1
		or r1 r1 r2
		brz .f16_mul__while1_end r1
		psh r7
		bsr r7 r7 1 
		bsr r4 r4 1 
		pop r8
		bsl r8 r8 15 
		or r4 r4 r8
		inc r5 r5
		jmp .f16_mul__while1
	.f16_mul__while1_end
		.f16_mul__if4_end
			sbrg .f16_mul__if5_elseif r5 0
			neg r5 r5 
			inc r5 r5 
			psh r7 
			psh r7
			bsr r7 r7 r5 
			bsr r4 r4 r5 
			sub r5 16 r5 
			pop r8
			pop r7 
			bsl r8 r8 r5 
			or r4 r4 r8 
			imm r5 0 
	.f16_mul__if5_elseif
		brl .f16_mul__if5_end r5 31
		and r1 r3 0x8000 
		or r1 r1 0x7c00
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret
	.f16_mul__if5_end
		bsl r1 r5 10 
		and r4 r4 1023 
		or r1 r1 r4 
		or r1 r1 r3
		pop r8
		pop r7
		pop r6
		pop r5
		pop r4
		pop r3
		pop r2
		pop r9
		ret

//EOF -----------------------------------------------------------------------------------
//assert.urcl ---------------------------------------------------------------------------
//basically compares 2 numbers (that are in registers 1 and 2 I might add(vars not supported yet)) and halts if not equal
.assert_reg
    bre .assert_err R1 R2 
    .assert_err
        cal .error
        hlt
    .error
        imm R1 .error_str
        cal .printf
        ret
    .error_str
        dw ["Assertion failed, terminating..." 0]
//EOF -----------------------------------------------------------------------------------
//math.urcl -----------------------------------------------------------------------------
.sqrt
    psh r1 // x
    psh r2 // tmp 
    bsl r2 15 10
    add r1 r1 r2
    rsh r1 r1
    pop r2
    pop r9
    ret
    
.pow
    psh r1 // short n
    psh r2 // short p
    psh r3 // output
    imm r3 1
    .pow_loop
        brz .pow_end r2
        mlt r3 r3 r1
        dec r2 r2
        jmp .pow_loop
    .pow_end
        mov r1 r3
        pop r3
        pop r2
        pop r0
        ret
//EOF -----------------------------------------------------------------------------------
.print_str
    // input data: r1 -> char*
    psh r1
    psh r2 // reserve reg
    imm r2 0
    .print_str__loop1
        lod r2 r1
        bre .print_str__endp r2 0
        out %text r2
        inc r1 r1
        jmp .print_str__loop1
    .print_str__endp
        pop r2
        pop r1
        ret

.printf // r1 = char*
    pop r9 // ret*
    str 0xee0 r1 
    str 0xee1 r2
    str 0xee2 r3
    imm r2 0
    .printf__loop1
        lod r2 r1
        bre .printf_str__endp r2 0
        bre .printf__perc r2 '%'
        out %text r2
        inc r1 r1
        jmp .printf__loop1
    .printf__perc
        inc r1 r1
        lod r2 r1
        bre .printf__percsub__d r2 'd'
        bre .printf__percsub__s r2 's'
        bre .printf__percsub__c r2 'c'
        bre .printf__percsub__perc r2 '%'
        jmp .printf__percsub__err
    .printf__percsub__perc
        out %text '%'
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__d
        pop r3
        out %numb r3
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__c
        pop r3
        out %text r3
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__s
        pop r3
        str 0xee3 r1
        mov r1 r3
        cal .print_str
        lod r1 0xee3
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__err
        imm r1 .printf__percsub__err_str
        psh r2
        cal .printf
    .printf_str__endp
        lod r3 0xee2
        lod r2 0xee1
        lod r1 0xee0
        jmp r9
    .printf__percsub__err_str
        dw [ "Wrong percentage-value %c" 0 ]

.print_int //int goes in r1
	out %int r1
	ret
//EOF -----------------------------------------------------------------------------------
//stdlib.urcl ---------------------------------------------------------------------------
.strlen
    psh r1 // str *
    psh r2 // additional reg
    psh r3
    imm r3 0
    .strlen__loop1
        lod r2 r1
        bre .strlen__end r2 0
        inc r3 r3
        inc r1 r1
        jmp .strlen__loop1
    .strlen__end
        mov r1 r3
        pop r3
        pop r2
        pop r9
        ret

.strcpy
    psh r1 // dest str*
    psh r2 // src str*
    psh r3 // additional reg
    .strcpy__loop1
        lod r3 r2
        bre .strcpy__end r3 0
        str r1 r3
        inc r2 r2
        inc r1 r1
        jmp .strcpy__loop1
    .strcpy__end
        pop r3
        pop r2
        pop r1
        ret


    
.memcpy
    psh r1 // dest *
    psh r2 // src *
    psh r3 // size
    psh r4 // additional
    .memcpy__loop1
        lod r4 r2
        str r1 r4
        dec r3 r3
        inc r1 r1
        inc r2 r2
        bre .memcpy__done r3 0
        jmp .memcpy__loop1
.memcpy__done
    pop r4
    pop r3
    pop r2
    pop r1
    ret
//EOF -----------------------------------------------------------------------------------
//audio.urcl ----------------------------------------------------------------------------
.bar0
DW [ e1 d8    e1 d8    0 d8    e1 d8   0 d8    c1 d8   c1 d4 ]
.bar1
DW [ g1 d4    0 d4    g d4    0 d4 ]
.bar2
DW [ c1 d4    0 d8    g d4    0 d8    e d4 ]
.bar3
DW [ 0 d4     a1 d4   b1 d4   as1 d8  a1 d4 ]
.bar4
DW [ g d6     e1 d6   g1 d6   a2 d4   f1 d8   g1 d8 ] 
.bar5
DW [ 0 d8     e1 d4   c1 d8   d1 d8   b1 d4   0 d8 ] // play from bar 2 again
.bar6
DW [ 0 d4     g1 d8   fs1 d8  ds1 d8  e1 d8 ]
.bar7
DW [ gs d8    a1 d8   c1 d8   0 d8    a1 d8   c1 d8   d1 d8 ] 
.bar8
DW [ 0 d4     g1 d8   fs1 d8  ds1 d4  e1 d8 ]
.bar9
DW [ 0 d8     c2 d4   c2 d8   c2 d4   0 d8 ]
.bar10
DW [ 0 d4     g1 d8   fs1 d8  ds1 d4  e1 d8 ]
.bar11
DW [ 0 d8     gs d8   a1 d8   c1 d8   0 d8    a1 d8   c1 d8   d1 d8 ]
.bar12
DW [ 0 d4     ds1 d4  0 d8    d1 d4   0 d8 ]
.bar13
DW [ c1 d4    0 d2    0 d4 ]
.bar14
DW [ c1 d8    c1 d8   0 d8    c1 d8   0 d8    c1 d8   d1 d4 ]


.play
    SUB r1 len 20
    OUT %NLEG r1
    OUT %WAIT len
    IN r0 %WAIT
    RET

.wait
    OUT %WAIT len
    IN r0 %WAIT
    RET
//EOF -----------------------------------------------------------------------------------
//END OF OS FILE
